import { mkdir, unlink, writeFile, readFile } from 'fs/promises';
import { performance } from 'perf_hooks';
import { existsSync } from 'fs';
import { join, relative, dirname } from 'pathe';
import { logger } from '@nuxt/kit';
import { createCheckerByJson } from 'vue-component-meta';
import { resolvePathSync } from 'mlly';
import { defu } from 'defu';

function useComponentMetaParser({
  outputDir = join(process.cwd(), ".component-meta/"),
  rootDir = process.cwd(),
  components: _components = [],
  componentDirs = [],
  checkerOptions,
  exclude = [],
  transformers = [],
  debug = false,
  metaFields,
  metaSources = {}
}) {
  const outputPath = join(outputDir, "component-meta");
  const isExcluded = (component2) => {
    return exclude.find((excludeRule) => {
      switch (typeof excludeRule) {
        case "string":
          return component2.filePath.includes(excludeRule);
        case "object":
          return excludeRule instanceof RegExp ? excludeRule.test(component2.filePath) : false;
        case "function":
          return excludeRule(component2);
        default:
          return false;
      }
    });
  };
  const components = { ...metaSources };
  for (const component2 of _components || []) {
    if (isExcluded(component2)) {
      continue;
    }
    if (!component2.filePath || !component2.pascalName) {
      continue;
    }
    const filePath = resolvePathSync(component2.filePath);
    components[component2.pascalName] = {
      ...component2,
      fullPath: filePath,
      filePath: relative(rootDir, filePath),
      meta: {
        type: 0,
        props: [],
        slots: [],
        events: [],
        exposed: []
      }
    };
  }
  const getStringifiedComponents = () => {
    const _components2 = Object.keys(components).map((key) => [
      key,
      {
        ...components[key],
        fullPath: void 0,
        shortPath: void 0,
        export: void 0
      }
    ]);
    return JSON.stringify(Object.fromEntries(_components2), null, 2);
  };
  const getVirtualModuleContent = () => `export default ${getStringifiedComponents()}`;
  let checker;
  const refreshChecker = () => {
    checker = createCheckerByJson(
      rootDir,
      {
        extends: `${rootDir}/tsconfig.json`,
        skipLibCheck: true,
        include: [
          "**/*",
          ...componentDirs.map((dir) => {
            const path = typeof dir === "string" ? dir : dir?.path || "";
            if (path.endsWith(".vue")) {
              return path;
            }
            return `${path}/**/*`;
          })
        ],
        exclude: []
      },
      checkerOptions
    );
  };
  const updateOutput = async (content2) => {
    const path = outputPath + ".mjs";
    if (!existsSync(dirname(path))) {
      await mkdir(dirname(path), { recursive: true });
    }
    if (existsSync(path)) {
      await unlink(path);
    }
    await writeFile(
      path,
      content2 || getVirtualModuleContent(),
      "utf-8"
    );
  };
  const stubOutput = async () => {
    if (existsSync(outputPath + ".mjs")) {
      return;
    }
    await updateOutput("export default {}");
  };
  const fetchComponent = async (component) => {
    if (!checker) {
      try {
        refreshChecker();
      } catch (e) {
        return;
      }
    }
    const startTime = performance.now();
    try {
      if (typeof component === "string") {
        if (components[component]) {
          component = components[component];
        } else {
          component = Object.entries(components).find(([, comp]) => comp.fullPath === component);
          if (!component) {
            return;
          }
          component = component[1];
        }
      }
      if (!component?.fullPath || !component?.pascalName) {
        return;
      }
      if (transformers && transformers.length > 0) {
        let code = await readFile(component.fullPath, "utf-8");
        for (const transform of transformers) {
          const transformResult = transform(component, code);
          component = transformResult?.component || component;
          code = transformResult?.code || code;
        }
        checker.updateFile(component.fullPath, code);
      }
      const { type, props, slots, events, exposed } = checker.getComponentMeta(component.fullPath);
      component.meta.type = metaFields.type ? type : 0;
      component.meta.slots = metaFields.slots ? slots : [];
      component.meta.events = metaFields.events ? events : [];
      component.meta.exposed = metaFields.exposed ? exposed : [];
      component.meta.props = (metaFields.props ? props : []).filter((prop) => !prop.global).sort((a, b) => {
        if (!a.required && b.required) {
          return 1;
        }
        if (a.required && !b.required) {
          return -1;
        }
        if (a.type === "boolean" && b.type !== "boolean") {
          return 1;
        }
        if (a.type !== "boolean" && b.type === "boolean") {
          return -1;
        }
        return 0;
      });
      component.meta.props = component.meta.props.map((sch) => stripeTypeScriptInternalTypesSchema(sch, true));
      component.meta.slots = component.meta.slots.map((sch) => stripeTypeScriptInternalTypesSchema(sch, true));
      component.meta.exposed = component.meta.exposed.map((sch) => stripeTypeScriptInternalTypesSchema(sch, true));
      component.meta.events = component.meta.events.map((sch) => stripeTypeScriptInternalTypesSchema(sch, true));
      const content = await readFile(component.fullPath, "utf-8");
      const extendComponentMetaMatch = content.match(/extendComponentMeta\((\{[\s\S]*?\})\)/);
      const extendedComponentMeta = extendComponentMetaMatch?.length ? eval(`(${extendComponentMetaMatch[1]})`) : null;
      component.meta = defu(component.meta, extendedComponentMeta);
      removeFields(component.meta, ["declarations"]);
      components[component.pascalName] = component;
    } catch (e) {
      debug && logger.info(`Could not parse ${component?.pascalName || component?.filePath || "a component"}!`);
    }
    const endTime = performance.now();
    if (debug === 2) {
      logger.success(`${component?.pascalName || component?.filePath || "a component"} metas parsed in ${(endTime - startTime).toFixed(2)}ms`);
    }
  };
  const fetchComponents = async () => {
    const startTime2 = performance.now();
    await Promise.all(Object.values(components).map(fetchComponent));
    const endTime2 = performance.now();
    if (!debug || debug === 2) {
      logger.success(`Components metas parsed in ${(endTime2 - startTime2).toFixed(2)}ms`);
    }
  };
  return {
    get checker() {
      return checker;
    },
    get components() {
      return components;
    },
    refreshChecker,
    stubOutput,
    outputPath,
    updateOutput,
    fetchComponent,
    fetchComponents,
    getStringifiedComponents,
    getVirtualModuleContent
  };
}
function removeFields(obj, fieldsToRemove) {
  if (obj && typeof obj === "object") {
    for (const key in obj) {
      if (fieldsToRemove.includes(key)) {
        delete obj[key];
      } else if (typeof obj[key] === "object") {
        removeFields(obj[key], fieldsToRemove);
      }
    }
  }
  return obj;
}
function stripeTypeScriptInternalTypesSchema(type2, topLevel = true) {
  if (!type2) {
    return type2;
  }
  if (!topLevel && type2.declarations && type2.declarations.find((d) => d.file.includes("node_modules/typescript") || d.file.includes("@vue/runtime-core"))) {
    return false;
  }
  if (Array.isArray(type2)) {
    return type2.map((sch) => stripeTypeScriptInternalTypesSchema(sch, false)).filter((r) => r !== false);
  }
  if (Array.isArray(type2.schema)) {
    return {
      ...type2,
      declarations: void 0,
      schema: type2.schema.map((sch) => stripeTypeScriptInternalTypesSchema(sch, false)).filter((r) => r !== false)
    };
  }
  if (!type2.schema || typeof type2.schema !== "object") {
    return typeof type2 === "object" ? { ...type2, declarations: void 0 } : type2;
  }
  const schema = {};
  Object.keys(type2.schema).forEach((sch) => {
    if (sch === "schema" && type2.schema[sch]) {
      schema[sch] = schema[sch] || {};
      Object.keys(type2.schema[sch]).forEach((sch2) => {
        const res2 = stripeTypeScriptInternalTypesSchema(type2.schema[sch][sch2], false);
        if (res2 !== false) {
          schema[sch][sch2] = res2;
        }
      });
      return;
    }
    const res = stripeTypeScriptInternalTypesSchema(type2.schema[sch], false);
    if (res !== false) {
      schema[sch] = res;
    }
  });
  return {
    ...type2,
    declarations: void 0,
    schema
  };
}

export { useComponentMetaParser };
